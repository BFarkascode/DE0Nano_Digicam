// Cleaned up ov2640 driver code. This is indifferent to what we run it on - SAMD21, SAMD51, NTX, ESP
//for notes, see the w_notes version of the code
//it does not activate any additional architecture for the clocking

//change this file to change camera or the setup!

#include "SAMD21_OV2640.h"

// REQUIRED EXTERN FUNCTIONS -----------------------------------------------

extern void OV2640_print(char *str);
extern int OV2640_read_register(void *platform, uint8_t reg);
extern void OV2640_write_register(void *platform, uint8_t reg, uint8_t value);

// UTILITY FUNCTIONS -------------------------------------------------------

// Write a 0xFF-terminated list of commands to the camera.

void OV2640_write_list(void *platform, OV2640_command *cmd) {
  for (int i = 0; cmd[i].reg <= OV2640_REG_LAST; i++) {											//we cycle thorugh all the possible addresses, from 0 to whichever the last address is (C9 on OV7670, OV2640 seemingly F9)
#if 0 // DEBUG
    char buf[50];
    sprintf(buf, "Write reg %02X = %02X\n", cmd[i].reg, cmd[i].value);
    OV2640_print(buf);
#endif
    OV2640_write_register(platform, cmd[i].reg, cmd[i].value);
    OV2640_delay_ms(1); // Required, else lockup on init
  }
}

// CAMERA STARTUP ----------------------------------------------------------

static const OV2640_command

		OV2640_init_SVGA[]	=				//comamnd and regsiter sequence taken from Arducam code. Vsynch will not be negative in this init. HREF and other specifications may also not work well with the FPGA. This will need to be checked.
 		{
		{0xff, 0x01},
		{0x12, 0x80},
		{0xff, 0x00},
		{0x2c, 0xff},
		{0x2e, 0xdf},
		{0xff, 0x01},
		{0x3c, 0x32},
		{0x11, 0x01},
		{0x09, 0x02},
		{0x04, 0x28},
		{0x13, 0xe5},
		{0x14, 0x48},
		{0x2c, 0x0c},
		{0x33, 0x78},
		{0x3a, 0x33},
		{0x3b, 0xfB},
		{0x3e, 0x00},
		{0x43, 0x11},
		{0x16, 0x10},
		{0x39, 0x92},
		{0x35, 0xda},
		{0x22, 0x1a},
		{0x37, 0xc3},
		{0x23, 0x00},
		{0x34, 0xc0},
		{0x36, 0x1a},
		{0x06, 0x88},
		{0x07, 0xc0},
		{0x0d, 0x87},
		{0x0e, 0x41},
		{0x4c, 0x00},
		{0x48, 0x00},
		{0x5B, 0x00},
		{0x42, 0x03},
		{0x4a, 0x81},
		{0x21, 0x99},
		{0x24, 0x40},
		{0x25, 0x38},
		{0x26, 0x82},
		{0x5c, 0x00},
		{0x63, 0x00},
		{0x61, 0x70},
		{0x62, 0x80},
		{0x7c, 0x05},
		{0x20, 0x80},
		{0x28, 0x30},
		{0x6c, 0x00},
		{0x6d, 0x80},
		{0x6e, 0x00},
		{0x70, 0x02},
		{0x71, 0x94},
		{0x73, 0xc1},
		{0x12, 0x40},					//SVGA is picked
		//{0x03, 0x0A}					//this might be necessary here if 0A is not default
		{0x17, 0x11},
		{0x18, 0x43},
		{0x19, 0x00},
		{0x1a, 0x4b},
		{0x32, 0x09},
		{0x37, 0xc0},
		{0x4f, 0x60},
		{0x50, 0xa8},
		{0x6d, 0x00},
		{0x3d, 0x38},
		{0x46, 0x3f},
		{0x4f, 0x60},
		{0x0c, 0x3c},
		{0xff, 0x00},
		{0xe5, 0x7f},
		{0xf9, 0xc0},
		{0x41, 0x24},
		{0xe0, 0x14},
		{0x76, 0xff},
		{0x33, 0xa0},
		{0x42, 0x20},
		{0x43, 0x18},
		{0x4c, 0x00},
		{0x87, 0xd5},
		{0x88, 0x3f},
		{0xd7, 0x03},
		{0xd9, 0x10},
		{0xd3, 0x82},
		{0xc8, 0x08},
		{0xc9, 0x80},
		{0x7c, 0x00},
		{0x7d, 0x00},
		{0x7c, 0x03},
		{0x7d, 0x48},
		{0x7d, 0x48},
		{0x7c, 0x08},
		{0x7d, 0x20},
		{0x7d, 0x10},
		{0x7d, 0x0e},
		{0x90, 0x00},
		{0x91, 0x0e},
		{0x91, 0x1a},
		{0x91, 0x31},
		{0x91, 0x5a},
		{0x91, 0x69},
		{0x91, 0x75},
		{0x91, 0x7e},
		{0x91, 0x88},
		{0x91, 0x8f},
		{0x91, 0x96},
		{0x91, 0xa3},
		{0x91, 0xaf},
		{0x91, 0xc4},
		{0x91, 0xd7},
		{0x91, 0xe8},
		{0x91, 0x20},
		{0x92, 0x00},
		{0x93, 0x06},
		{0x93, 0xe3},
		{0x93, 0x05},
		{0x93, 0x05},
		{0x93, 0x00},
		{0x93, 0x04},
		{0x93, 0x00},
		{0x93, 0x00},
		{0x93, 0x00},
		{0x93, 0x00},
		{0x93, 0x00},
		{0x93, 0x00},
		{0x93, 0x00},
		{0x96, 0x00},
		{0x97, 0x08},
		{0x97, 0x19},
		{0x97, 0x02},
		{0x97, 0x0c},
		{0x97, 0x24},
		{0x97, 0x30},
		{0x97, 0x28},
		{0x97, 0x26},
		{0x97, 0x02},
		{0x97, 0x98},
		{0x97, 0x80},
		{0x97, 0x00},
		{0x97, 0x00},
		{0xc3, 0xed},
		{0xa4, 0x00},
		{0xa8, 0x00},
		{0xc5, 0x11},
		{0xc6, 0x51},
		{0xbf, 0x80},
		{0xc7, 0x10},
		{0xb6, 0x66},
		{0xb8, 0xA5},
		{0xb7, 0x64},
		{0xb9, 0x7C},
		{0xb3, 0xaf},
		{0xb4, 0x97},
		{0xb5, 0xFF},
		{0xb0, 0xC5},
		{0xb1, 0x94},
		{0xb2, 0x0f},
		{0xc4, 0x5c},
		{0xc0, 0x64},
		{0xc1, 0x4B},
		{0x8c, 0x00},
		{0x86, 0x3D},
		{0x50, 0x00},
		{0x51, 0xC8},
		{0x52, 0x96},
		{0x53, 0x00},
		{0x54, 0x00},
		{0x55, 0x00},
		{0x5a, 0xC8},
		{0x5b, 0x96},
		{0x5c, 0x00},
		{0xd3, 0x82},
		{0xc3, 0xed},
		{0x7f, 0x00},
		{0xda, 0x00},
		{0xe5, 0x1f},
		{0xe1, 0x67},
		{0xe0, 0x00},
		{0xdd, 0x7f},
		{0x05, 0x00},			//no DSP bypass
		{0xff, 0xff},
		{OV2640_REG_LAST + 1, 0x00},       // End-of-data marker
		},


		OV2640_rgb[] =
		{
		{0xFF, 0x00},			//go to DSP
		{0x05, 0x00},			//no DSP bypass
		{0xC2, 0x0e},			//enable RGB565 module
		{0xDA, 0x08},			//RGB565 enabled, no JPEG
		{0xD7, 0x03},			//RSVD - always 0x03
		{0xDF, 0x00},			//RSVD - just in yuv
		{0x33, 0x80},			//RSVD - 0x80, 0x78 or 0xa0
		{0x3C, 0x40},			//RSVD - unknown
		{0xe1, 0x77},			//RSVD - 0x67 or 0x77
		{0x00, 0x00},			
		{0xff, 0xff},			//end transmit
		{OV2640_REG_LAST + 1, 0x00},       // End-of-data marker
},


//OV7670 init

OV7670_QVGA[] =
	{
	{0x3a, 0x04},								//line buffer. set to reserved
    {0x40, 0xd0},								//COM15 - data format - 11010000 (RGB565 picked, full range) - only works in tandem with COM7 to choose the RGB output 565 or 555 (OD 0xd0)
    {0x12, 0x04},								//COM7 - register reset, resolution selection, colour definition - 10100 - QVGA and RGB picked (works with COM15)	(OG 0x14)	
												//change register to 0x04 for 640x480 VGA output
    {0x32, 0x80},								//HREF control - HREF control - 10000000 - default value, HREF edge offset
    {0x17, 0x16},								//HSTART - HSTART - 10110 - output format
    {0x18, 0x04},								//HSTOP
    {0x19, 0x02},								//VSTRT
    {0x1a, 0x7b},								//VSTOP
    {0x03, 0x06},								//VREF - vertical frame control - VREF end low bits
    {0x0c, 0x00},								//COM3 - MSB/LSB swap, tristate,DCW, scale - default 00
    {0x3e, 0x00},								//COM14 - PCLK divider, DCW scaling - divided by 1 
	
    {0x70, 0x00},								//scaling registers
    {0x71, 0x00},
    {0x72, 0x11},
    {0x73, 0x00},
	
    {0xa2, 0x02},								//PCLK delay - default 02
	
    {0x11, 0x81},								//internal clock - default 80
	
    {0x7a, 0x20},								//gamma values
    {0x7b, 0x1c},
    {0x7c, 0x28},
    {0x7d, 0x3c},
    {0x7e, 0x55},
    {0x7f, 0x68},
    {0x80, 0x76},
    {0x81, 0x80},
    {0x82, 0x88},
    {0x83, 0x8f},
    {0x84, 0x96},
    {0x85, 0xa3},
    {0x86, 0xaf},
    {0x87, 0xc4},
    {0x88, 0xd7},
    {0x89, 0xe8},
	
    {0x13, 0xe0},								//COM8 - AGC, AEC - gain control, banding filter control - 11100000 - banding filter off, AGC off
	
    {0x00, 0x00},								//default gain settings
	
    {0x10, 0x00},								//exposure value
	
    {0x0d, 0x00},								//COM4 - windowing - full window
	
    {0x14, 0x28},								//COM9 - gain ceiling - 101000 - reserved values
	
    {0xa5, 0x05},								//banding filter control
    {0xab, 0x07},
	
    {0x24, 0x75},								//AGC/AEC controls
    {0x25, 0x63},
    {0x26, 0xA5},
	
    {0x9f, 0x78},								//luminescence values
    {0xa0, 0x68},
    {0xa1, 0x03},
    {0xa6, 0xdf},
    {0xa7, 0xdf},
    {0xa8, 0xf0},
    {0xa9, 0x90},
	
    {0xaa, 0x94},								//AEC alogrythm selection
	
    {0x13, 0xe5},								//COM8 - AGC, AEC - gain control, banding filter control - 11100101 - enable AGC
    {0x0e, 0x61},
    {0x0f, 0x4b},								//COM6 - optical black control, format counter reset  - 1000011 - format, disable href at optical black (OG 0x4b)
	
    {0x16, 0x02},								//RSVD
	
    {0x1e, 0x17},								//MFVP - mirror and flip - 10111 - vertical flip on image (OG 0x17)
	
    {0x21, 0x02},								//RSVD
    {0x22, 0x91},
    {0x29, 0x07},
    {0x33, 0x0b},
    {0x35, 0x0b},
	
    {0x37, 0x1d},								//ADC and current control
    {0x38, 0x71},
    {0x39, 0x2a},
	
    {0x3c, 0x78},								//COM12 - HREF control - 1111000 - allways has HREF, even when VSYNCH is low (OG 0x78)
	
    {0x4d, 0x40},								//DMPOS - dummy row - 1000000 - we have one dummy row after active row (OG 0x40)
	
    {0x4e, 0x20},
	
    {0x69, 0x00},								//gain control
	
    {0x6b, 0x00},								//PLL control - default 00
	
    {0x74, 0x19},								//RSVD
    {0x8d, 0x4f},	
    {0x8e, 0x00},
    {0x8f, 0x00},
    {0x90, 0x00},
    {0x91, 0x00},
    {0x92, 0x00},
    {0x96, 0x00},
    {0x9a, 0x80},
    {0xb0, 0x84},
    {0xb1, 0x0c},
    {0xb2, 0x0e},
    {0xb3, 0x82},
    {0xb8, 0x0a},
	
    {0x43, 0x14},								//AWB control
    {0x44, 0xf0},
    {0x45, 0x34},
    {0x46, 0x58},
    {0x47, 0x28},
    {0x48, 0x3a},	
    {0x59, 0x88},
    {0x5a, 0x88},
    {0x5b, 0x44},
    {0x5c, 0x67},
    {0x5d, 0x49},
    {0x5e, 0x0e},
	
    {0x64, 0x04},								//lens correction
    {0x65, 0x20},
    {0x66, 0x05},	
    {0x94, 0x04},
    {0x95, 0x08},
	
    {0x6c, 0x0a},								//AWB
    {0x6d, 0x55},
    {0x6e, 0x11},
    {0x6f, 0x9f},
    {0x6a, 0x40},
    {0x01, 0x40},
    {0x02, 0x40},

    {0x13, 0xe7},								//COM8 - AGC (OG 0xe7)
	
    {0x15, 0x00},								//COM10 - HREF to HSYNCH, VSYNCH negation, etx. - 10 - vsynch is negative, href is NOT hysnch (OG 0x02)
	
    {0x4f, 0x80},								//MTX
    {0x50, 0x80},
    {0x51, 0x00},
    {0x52, 0x22},
    {0x53, 0x5e},
    {0x54, 0x80},
    {0x58, 0x9e},
	
    {0x41, 0x08},								//COM 16 - edge enhancement - works with EDGE and REG75 and REG76 - AWB gain enabled
    
	{0x3f, 0x00},								//edge enhancement
	
    {0x75, 0x05},								//REG75	-	edges
    {0x76, 0xe1},								//REG76 -	edges
	
    {0x4c, 0x00},								//de-noise strenght - default 00
    {0x77, 0x01},

    {0x3d, 0xc2},  								//COM13 - gamma control - 11000010 - gamma enable, UV swap
    {0x4b, 0x09},
    {0xc9, 0x60},								//uv stauration control
	
    {0x41, 0x38},								//COM16 - edge

    {0x56, 0x40},								//contrast control - default 40

    {0x34, 0x11},								//array current control

    {0x3b, 0x02},								//COM11 - night mode - 10 - no night mode

    {0xa4, 0x89},								//autofram adjustment
	
    {0x96, 0x00},								//RSVD
    {0x97, 0x30},
    {0x98, 0x20},
    {0x99, 0x30},
    {0x9a, 0x84},
    {0x9b, 0x29},
    {0x9c, 0x03},
	
    {0x9d, 0x4c},								//banding filter
    {0x9e, 0x3f},
	
    {0x78, 0x04},   							//RSVD
    {0x79, 0x01},	
    {0xc8, 0xf0},
    {0x79, 0x0f},
    {0xc8, 0x00},
    {0x79, 0x10},
    {0xc8, 0x7e},
    {0x79, 0x0a},
    {0xc8, 0x80},
    {0x79, 0x0b},
    {0xc8, 0x01},
    {0x79, 0x0c},
    {0xc8, 0x0f},
    {0x79, 0x0d},
    {0xc8, 0x20},
    {0x79, 0x09},
    {0xc8, 0x80},
    {0x79, 0x02},
    {0xc8, 0xc0},
    {0x79, 0x03},
    {0xc8, 0x40},
    {0x79, 0x05},
    {0xc8, 0x30},
    {0x79, 0x26},
	
    {0x09, 0x03},								//COM2 - sleep mode - 11 - output drive capacity
    {0x3b, 0x42},								//COM11 - nigth mode - 1000010 - frame rate night mode
	{0xff, 0xff},
};
		
//The function below starts the camera

OV2640_status OV2640_begin(OV2640_host *host) {													//this is a simplified begin function with the colourspace, the size and the fps selection removed
  OV2640_status status;

  // I2C must already be set up and running (@ 100 KHz) in calling code in the element that specifies, which micro we are using

  //We activate the architecture within the samd51 and expect an OK status reply
//  status = OV2640_arch_begin(host);																						//REMOVED for debugging!!!!!!!!!!!!!
  
  
  if (status != OV2640_STATUS_OK) {
    return status;
  }

  OV2640_delay_ms(300);

  // ENABLE AND/OR RESET CAMERA --------------------------------------------


  //We go into host, pins, enable and put it to 0 if it is not at 0 already
  if (host->pins->enable >= 0) { // Enable pin defined?
    OV2640_pin_output(host->pins->enable)															//within the "host, go into "pins" and then define the "enable" pin as an output
        OV2640_pin_write(host->pins->enable, 0); // PWDN low (enable)
    OV2640_delay_ms(300);
  }

  //We do the same for the reset pin
  if (host->pins->reset >= 0) { // Hard reset pin defined?
    OV2640_pin_output(host->pins->reset);
    OV2640_pin_write(host->pins->reset, 0);
    OV2640_delay_ms(1);
    OV2640_pin_write(host->pins->reset, 1);
  } else {

  }
  OV2640_delay_ms(1); // Datasheet: tS:RESET = 1 ms
  
  //we call the write list function on the platform and the rgb setup
  
  
  //We initialize the camera here
//  OV2640_write_list(host->platform, OV2640_init_SVGA); 				//we send the initiation list down the pipe
  
  OV2640_write_list(host->platform, OV7670_QVGA);				//we call the OV7670 set of commands										//change this if another camera is being used

  //We pick the colour palette here
//  OV2640_write_list(host->platform, OV2640_rgb);				//we send the command list for rgb down the pipe
  
  //We pick the resolution here
//  OV2640_write_list(host->platform, OV2640_rgb);				//we send the command list for a certain resolution down the pipe. Currently not used.

  //WE wait a bit.
  OV2640_delay_ms(300); // tS:REG = 300 ms (settling time = 10 frames)

  //We return an OK status when succesful
  return OV2640_STATUS_OK;
}

//The above function is the begin function for the camera
//it activates the architecture
//it pulls the respective pins LOW
//and then sends the list of commands down the pipe for colour and init
//followed by setting the size. This is currently not active in oder to make SVGA work first. Once done, we need to shift the setup to UXGA